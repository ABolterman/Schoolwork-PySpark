# -*- coding: utf-8 -*-
"""Data Science II - Programming Assignment 4

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HWok6P2_Picj8nYONg8dBsywFHxa5bBe

# Initial Setup
"""

!pip install -q pyspark

!wget -q 'https://drive.google.com/uc?export=download&id=1wM6-8MiNQpyYwAr4CUnRt2C96iJNKIKS' -O 'SmallFriends.txt'
!wget -q 'https://drive.google.com/uc?export=download&id=1SCrN7OZMQaVr-otJsMdzwXe6CD89DZY0' -O 'Friends.txt'

from pyspark import SparkContext, SparkConf
from pyspark.sql import SparkSession
import string
conf = SparkConf().setAppName('SparkWordCount')
sc = SparkContext.getOrCreate(conf = conf)

sqlContext = SparkSession.builder\
        .master("local")\
        .appName("Colab")\
        .config('spark.ui.port', '4050')\
        .getOrCreate()

"""
$~$

---



# Finding Pairs with a Mutual Friend"""

test_file = sc.textFile('SmallFriends.txt')
input_file = sc.textFile('Friends.txt')

def find_friend_pairs(line):
    pairs = []
    potentials = line.split()
    for item in potentials:
        friends = item.split(",")
        for person in friends:
          for other in friends:
            if person == other:
              continue
            else:
              pair = (person, other)
              pairs.append(pair)
    return pairs

# test_pairs = test_file.flatMap(lambda line: find_friend_pairs(line)).map(lambda pair: (pair, 1)).reduceByKey(lambda a, b: a+b)
# test_pairs.collect()[:5]
real_pairs = input_file.flatMap(lambda line: find_friend_pairs(line)).map(lambda pair: (pair, 1)).reduceByKey(lambda a, b: a+b)

"""
$~$

---

## Finding Existing Friends"""

def find_existing_friends(line):
    potentials = line.split()
    existing = []
    for item in potentials:
      if potentials.index(item) %2 == 0:
        person = item
      else:
        friends = item.split(",")
        for friend in friends:
          pair = (person, friend)
          existing.append(pair)
    return existing

# test_existing_friends = test_file.flatMap(lambda line: find_existing_friends(line)).map(lambda pair: (pair, -9999999999))
# test_existing_friends.collect()[:1]
real_existing_friends = input_file.flatMap(lambda line: find_existing_friends(line)).map(lambda pair: (pair, -9999999999))

"""
$~$

---
## Removing Existing Friends from Found Pairs"""

def to_list(a):
    return [a]
def append(a, b):
    a.append(b)
    return a
def extend(a, b):
    a.extend(b)
    return a

# test_suggested_friends = test_pairs.union(test_existing_friends).reduceByKey(lambda a, b: a+b)
# test_suggested_friends = test_suggested_friends.map(lambda pair: (pair[0][0], (pair[0][1], pair[1]))).combineByKey(to_list, append, extend).sortByKey()
# test_suggested_friends.collect()[:1]
real_suggestions = real_pairs.union(real_existing_friends).reduceByKey(lambda a, b: a+b)
real_suggestions = real_suggestions.map(lambda pair: (pair[0][0], (pair[0][1], pair[1]))).combineByKey(to_list, append, extend).sortByKey()


N = 10

def remove_existing_friends(potential_friends):
  suggested_friend_pairs = []
  for item in potential_friends:
    if type(item) == str:
      person = item
      sorted = []
    else:
      for pot in item:
        if pot[1] < 0:
          continue
        else:
          sorted.append(pot)
      suggested_friend_pairs.append((person, sorted))
  return suggested_friend_pairs

# test_suggestions = test_suggested_friends.flatMap(lambda pair: remove_existing_friends(pair))
# test_suggestions.collect()
real_suggestions = real_suggestions.flatMap(lambda pair: remove_existing_friends(pair))
# real_suggestions.collect()[:1]

"""
$~$

---
## Finding Specific Recommendations
"""

from pyspark.sql.functions import filter
N = 10
ids_to_find = ['18', '87', '480', '512', '3971', '38283', '49772', '1838']

def get_specific(ids, suggests, n=N):
  suggsDF = sqlContext.createDataFrame(suggests) \
              .withColumnRenamed('_1','UserID').withColumnRenamed('_2','Recommendations')
  filtered = suggsDF.filter(suggsDF.UserID.isin(ids))
  filtered_list = filtered.collect()
  ids_found=filtered.rdd.map(lambda x: x.UserID).collect()
  for number in ids_to_find:
    if number in ids_found:
      index = ids_found.index(number)
      potentials = filtered_list[index][1]
      if len(potentials) >= 2:
        for i in range(len(potentials)):
          for j in range(0, len(potentials)-i-1):
            if potentials[j][1] < potentials[j + 1][1]:
                  temp = potentials[j]
                  potentials[j] = potentials[j + 1]
                  potentials[j + 1] = temp
            if potentials[j][1] == potentials[j + 1][1]:
              if int(potentials[j][0]) > int(potentials[j+1][0]):
                temp = potentials[j]
                potentials[j] = potentials[j + 1]
                potentials[j + 1] = temp
      suggestions = []
      for i in range(n):
        if i >= len(potentials):
          break
        item = potentials[i]
        suggestions.append(item[0])
      suggestion = ','.join([str(elem) for elem in suggestions])
    else:
      suggestion = ""
    print(f"{number}\t{suggestion}")

get_specific(ids_to_find, real_suggestions)

"""
## Generating All"""

N = 10

def sort_possible_friends(potential_friends):
  suggested_friend_pairs = []
  for item in potential_friends:
    if type(item) == str:
      person = item
      sorted = []
    else:
      for pot in item:
        if pot[1] < 0:
          continue
        else:
          sorted.append(pot)
      for i in range(len(sorted)):
        for j in range(0, len(sorted)-i-1):
          if sorted[j][1] < sorted[j + 1][1]:
                temp = sorted[j]
                sorted[j] = sorted[j + 1]
                sorted[j + 1] = temp
          if sorted[j][1] == sorted[j + 1][1]:
            if int(sorted[j][0]) > int(sorted[j+1][0]):
              temp = sorted[j]
              sorted[j] = sorted[j + 1]
              sorted[j + 1] = temp
      suggestions = []
      for i in range(N):
        if i >= len(sorted):
          break
        item = sorted[i]
        suggestions.append(item[0])
      suggested_friend_pairs.append((person, sorted))
  return suggested_friend_pairs

sorted_suggestions = real_suggestions.flatMap(lambda pair: sort_possible_friends(pair))
df = sqlContext.createDataFrame(sorted_suggestions)
df.toPandas().to_csv('counts.csv', index=False)